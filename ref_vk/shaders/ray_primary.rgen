#version 460 core
#extension GL_GOOGLE_include_directive : require

#include "ray_primary_common.glsl"

layout(set = 0, binding = 0) buffer writeonly restrict Result { PrimaryRay out_primary_ray[]; };

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 2) uniform UBO { UniformBuffer ubo; };

layout(location = PAYLOAD_LOCATION_PRIMARY) rayPayloadEXT RayPayloadPrimary payload;

void main() {
	vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;

	// FIXME start on a near plane
	vec3 origin    = (ubo.inv_view * vec4(0, 0, 0, 1)).xyz;
	vec4 target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	vec3 direction = (ubo.inv_view * vec4(normalize(target.xyz), 0)).xyz;

	const uint flags = gl_RayFlagsCullFrontFacingTrianglesEXT;
	const uint sbt_offset = 0;
	const uint sbt_stride = 0;
	const float L = 10000.; // TODO Why 10k?
	traceRayEXT(tlas, flags, GEOMETRY_BIT_OPAQUE, // | GEOMETRY_BIT_REFRACTIVE,
		sbt_offset, sbt_stride, SHADER_OFFSET_MISS_REGULAR,
		origin, 0., direction, L,
		PAYLOAD_LOCATION_PRIMARY);

	const uvec2 _gl_WorkGroupSize = uvec2(16, 8);
	const uvec2 _gl_WorkGroupID = gl_LaunchIDEXT.xy / _gl_WorkGroupSize;
	const uvec2 _gl_LocalInvocationID = gl_LaunchIDEXT.xy % _gl_WorkGroupSize;
	const uvec2 res = gl_LaunchSizeEXT.xy;

	const uint ray_index = gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x;
	out_primary_ray[ray_index] = payload.data;
}
